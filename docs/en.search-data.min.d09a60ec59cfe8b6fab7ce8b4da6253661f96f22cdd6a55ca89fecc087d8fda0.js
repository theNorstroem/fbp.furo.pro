'use strict';(function(){const indexCfg={cache:true};indexCfg.doc={id:'id',field:['title','content'],store:['title','href','section'],};const index=FlexSearch.create('balance',indexCfg);window.bookSearchIndex=index;index.add({'id':0,'href':'/docs/installation/','title':"Installlation",'section':"Docs",'content':"Installation #  You can use furo FBP directly in your HTML documents or within your own web-components.\nFBP within HTML #  You can use furo FBP inside your HTML by using furo-fbp. Make sure that you have imported the components that you want to use.\nfuro-fbp is a web-component which will generate and register the defined component. These components can be directly used in your HTML documents.  You can import furo-fbp from the CDN or npm. Note the type=\u0026ldquo;module\u0026rdquo;\nWith CDN\n1  \u0026lt;script type=\u0026#34;module\u0026#34; src=\u0026#34;https://cdn.jsdelivr.net/npm/@furo/fbp@5.8.1/assets/furo-fbp.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt;   With npm\n1  \u0026lt;script type=\u0026#34;module\u0026#34; src=\u0026#34;/node_modules/@furo/fbp/src/furo-fbp.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt;   index.html with cdn example\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32  \u0026lt;head\u0026gt; \u0026lt;script type=\u0026#34;module\u0026#34; src=\u0026#34;https://cdn.jsdelivr.net/npm/@furo/fbp@5.8.1/assets/furo-fbp.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;!-- use the component as many times you want, even before the definition--\u0026gt; \u0026lt;language-sample\u0026gt;\u0026lt;/language-sample\u0026gt; \u0026lt;hey-component\u0026gt;\u0026lt;/hey-component\u0026gt;  \u0026lt;!-- define the component --\u0026gt; \u0026lt;furo-fbp name=\u0026#34;language-sample\u0026#34;\u0026gt; \u0026lt;template\u0026gt; \u0026lt;button @-click=\u0026#34;--playClicked\u0026#34;\u0026gt;play\u0026lt;/button\u0026gt; \u0026lt;button @-click=\u0026#34;--pauseClicked\u0026#34;\u0026gt;pause\u0026lt;/button\u0026gt; \u0026lt;audio ƒ-play=\u0026#34;--playClicked\u0026#34; ƒ-pause=\u0026#34;--pauseClicked\u0026#34; src=\u0026#34;https://upload.wikimedia.org/wikipedia/commons/9/92/German_alphabet-2.ogg\u0026#34;\u0026gt;\u0026lt;/audio\u0026gt; \u0026lt;!-- use other components that you have defined --\u0026gt; \u0026lt;hey-component\u0026gt;\u0026lt;/hey-component\u0026gt;  \u0026lt;/template\u0026gt; \u0026lt;/furo-fbp\u0026gt; \u0026lt;!-- define the component --\u0026gt; \u0026lt;furo-fbp name=\u0026#34;hey-component\u0026#34;\u0026gt; \u0026lt;template\u0026gt; \u0026lt;span\u0026gt;Hej\u0026lt;/span\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;/furo-fbp\u0026gt; \u0026lt;/body\u0026gt;    line 2: load furo-fbp via cdn line 7: use the hey-component directly line 7: use the hey-component inside of the language-sample component line 26-30: define the hey-component   The result of the example from above:\n    play pause      Hej   Install the npm module #  To work with lit or native web components you need the npm module @furo/fbp.\n1  npm i -S @furo/fbp   FBP with lit-element #  To use FBP with lit, just extend your class.\n1 2 3 4  class MyComponent extends FBP(LitElement) {  } window.customElements.define(\u0026#39;my-component\u0026#39;, MyComponent);   FBP with native web-components #  To use furo-fbp with native components, call this._appendFBP(this.shadowRoot); to enable fbp.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  class MyComponent extends FBP(HTMLElement) { constructor() { super(); // Create a shadow root to the element.  this.attachShadow({mode: \u0026#39;open\u0026#39;}); this.shadowRoot.appendChild(template.content.cloneNode(true)); // Append FBP to my-component  this._appendFBP(this.shadowRoot);  } } window.customElements.define(\u0026#39;my-component\u0026#39;, MyComponent);   FBP with polymer #  To use FBP with polymer, just extend your class.\n1 2 3 4  class MyComponent extends FBP(PolymerElement) {  } window.customElements.define(\u0026#39;my-component\u0026#39;, MyComponent);   "});index.add({'id':1,'href':'/docs/fbp-basics/','title':"Getting Started",'section':"Docs",'content':"Getting Started #  Write your applications like you make the concept for your application. Normaly you draw a few components and some arrows to connect the components, to describe your intention. Why you don’t do the same to write your app or component? Use existing web-components and wire them to build up your application.\nFuro FBP 101 #  In furo-FBP you connect events from one component to methods of anohter component. If you get this simple concept, you have understand already 90% of the things you need to write a program.\nConnecting things #  We have a lightswitch furo-button and a light bulb light-bulb which we want to toggle when the switch is clicked.\nWhen the button fires a click event, the action will trigger the toggle method of the light-bulb because it is connected by the wire --lightSwitchClicked.\n     This doesnt look very impressive in the first moment. But as you can see, there is no scripting involved and there are no id\u0026rsquo;s assigned to the components.\nHint\n Click on demo to see the flow in action. Click on source to see the corresponding source. Click on flow to see the resulting flow of the source.   Multiple targets #  A wire can have as many targets as you want.\nSo the wire --lightSwitchClicked can trigger multiple targets if you want.\n        When you press the button, all elements which are connected to the wire will trigger the defined function. In this example the last light-bulb is not connected.\nName of the wire\nYou can name a wire with alphanumeric characters without a \u0026ldquo;space\u0026rdquo;.\nIt is a good practice to name the wire by the thing that happened like --saveClicked or by the values it will transport like --responseData. The dashes are not needed, but it makes the code easier to read too.\n Name of the wire\nSometimes people tend to name the wire by the target action that the wire will trigger (--saveData). THIS IS NOT a good idea and will result in unreadable flows.\nAssume that your team want to introduce some other features, like playing a animation.\n1 2 3 4 5  \u0026lt;!-- bad wire name--\u0026gt; \u0026lt;some-animation ƒ-play=\u0026#34;--saveData\u0026#34;\u0026gt;\u0026lt;/some-animation\u0026gt; \u0026lt;!-- good wire name --\u0026gt; \u0026lt;some-animation ƒ-play=\u0026#34;--saveClicked\u0026#34;\u0026gt;\u0026lt;/some-animation\u0026gt;     Multiple sources #  A wire is not limited as a point to point connection and can have multiple sources.\n      It doesn\u0026rsquo;t matter if you press the first or the second light switch. Both of them will trigger the wire--lightSwitchClicked, which will invoke the toggle method on the light-bulb.\nMultiple sources and targets #  A wire is not limited as a point to point connection and can have multiple sources and also have multiple targets.\n         If you look at the source of this example, it doesn\u0026rsquo;t look very complex, the resulting flow of this example is quite complex.\nTriggering multiple wires from one source event #  Sometimes you want to trigger multiple wires from one source event. You can do this by separating them with a comma. @-click=\u0026quot;--lightSwitchClicked, --blinkerClicked\u0026quot;\n         When you press the button, it will trigger the --lightSwitchClicked and the --blinkerClicked wire.\nReceiving multiple wires on a target #  You can receive from multiple wires by comma separating them.\n         *The light bulb on the top right will be triggered by the --lightSwitchClicked and --intervallPulse wire *\n"});index.add({'id':2,'href':'/docs/web-components/','title':"furo web",'section':"Docs",'content':"フロー Furo Web Components #  Furo Web Components provides an enterprise ready set of web components which play seamlessly with Furo. Based on web standards and future proved. Compliant with any technology of choice. With minimal footprint it includes all enterprise standards, i18n, theming and much more.\nThe furo web components are a wide set of components which covers everything you need to write a web application. They consume the same types which are defined with furo.\nPowered by lit Many of the world\u0026rsquo;s most forward-looking organizations are building with Lit. We too. Most of our components are using lit or elsewhere native web components.\n Programmable HTML Furo FBP is like programmable HTML, no deep javascript knowledge is needed to write an application. The flowbased programming paradigm results in less complex and more flexible code.   SAP UI5, Google Material or any other design system A set of input elements which will work with the furo data structure out of the box, are available for a wide set of types.\nOur ui5 components i.e. are just extending the excellent UI5 Web Components, the Enterprise-flavored sugar on top of native APIs!.\nIf this is not enough, it is no problem to write your own components, by using the data adapter.\n Data Integration The transparent data agents are responsible for the communication with the APIs and the adapters for the UI interaction.\n mermaid.initialize({ \"flowchart\": { \"useMaxWidth\":true }, \"theme\": \"default\" } ) graph TD UI[UI elements]-- HTML ---agent[Data Agents] agent-- REST ---API   "});index.add({'id':3,'href':'/docs/fbp-wires-data/','title':"Wire Data",'section':"Docs",'content':"Data on wires #  Wires are not limited to triggering something, they also transport information.\nNote\nBy default the content of EVENT.detail is passed to the target. If an event does not have a detail property, the receiver will get a undefined.\n Passing useful data to target #       The color picker dispatches a value-changed event, with the color as payload.\nSend the complete event instead of event.detail #  You can put the complete event or any sub.property of the event on the wire by defining the details at the producer / triggerer.\nProducer (@-) #  You can define exactly what you want to put on the wire on the producing side.\n @-event=\u0026quot;\u0026ndash;wireName(*)\u0026quot; will send the complete event. @-event=\u0026quot;\u0026ndash;wireName(*.key)\u0026quot; will send the property key of the event.  Receiver (ƒ-) #  You can pass a subset of the data on a wire to a receiver.\n ƒ-doit=\u0026quot;\u0026ndash;wireName(*.title)\u0026quot; will call doit(wiredata.title)on the receiver. ƒ-doit=\u0026quot;\u0026ndash;wireName(*.page.2.title)\u0026quot; will call doit(wiredata.page[2].title) on the receiver with checks that index 2 and the sub property really exist.  Storing event data on a class member property (aka parking) #  Sometimes you want to store data for later usage. To store data from an event write the property that you want to update in a double bracket ((targetProperty)).\n @-value-changed=\u0026quot;((color1)) will update the component property color1 with the value of EVENT.detail.  Note\nKeep in mind that you will overwrite existing properties of your host. A name like shadowRoot can cause problems.\n     Look at the example below to see how you can use parked data\nSending host member properties with events #  To send parked data, write the property name in brackets after the wire.\n @-click=\u0026quot;\u0026ndash;newColor(color1)\u0026quot; will put the value of color1 on the wire --newColor instead of the detail value of the click event.        "});index.add({'id':4,'href':'/docs/fbp-wires-more/','title':"Compatibility",'section':"Docs",'content':"Working with suboptimal components #  Some components that you may want or have to use are not dispatching events or receiving data by methods. Therefore, furo FBP has some features to work with them too.\nSetting a member value #  To set a value of a component you use can be done with the ƒ-.property.\n A click counter   Note, a property is not an attribute.\nYou have to know what you do. This is a direct manipulation of a component and maybe there is some reason why it does not expose the property.\n Wireing responses from method calls #  When the method that you have wired only returns data that you want to use, you can wire the response with @-ƒ-methodname.\n calculate sqrt      The response of the calculate(n) method is avaliable on the wire --calculatedSqrRoot.\nSpread arguments #  When a receiver mehtod accepts multiple arguments or is a spread operator and the data on the wire is spreadable, furo FBP will handle this for you correctly.\n"});index.add({'id':5,'href':'/docs/fbp-events/','title':"Custom Events",'section':"Docs",'content':"Fireing custom events #  Web Components use events to communicate state changes up the DOM tree to parent elements.\nFuro also provides a notation for events which allows you to specify events in a declarative manner. This is very useful when you want to trigger a event with a more specific name then the originating event has.\n*On the first view, it does not make sense to rename events. Take a look at the example below to get a better understanding. controller-component\n play pause stop   my-player\n     Imagine a simple controller component with some buttons. Each of them will dispatch a simple click. Using @-click on the controller inside of the my-player can not distinguish which button was pressed.\n learn more about events\u0026hellip;\nNon bubbling events #  Non bubbling events will, as the name says, not bubble and stop at the next dom parent.\nTo fire a non-bubbling-event use ^event-name.\n Search    Bubbling events #  To fire a bubbling-event use ^^event-name. Bubbling is useful if you want or have to use the event in a parent component. It is a good practice to document the bubbling events from the child components.\n Search    the general-error event will bubble.\nNon bubbling host events #  With -^ you can dispatch an event, which is available on the host only, but does not bubble. This is useful when you want to mimic the blur event (which does not bubble) on the outside of your component.\nSending host data with events #  Sometimes you want to send some values with your event, when the default event.detail is not useful. You can send any host property with your event by giving the property name in brackets like ^^some-event(propertyName) .\nbubbling event with custom data\n1  \u0026lt;paper-button @-click=\u0026#34;^^some-event(_privateProperty)\u0026#34;\u0026gt; check \u0026lt;/paper-button\u0026gt;   The click event sends usually a number for the amount of clicks with a certain time distance. So it will send 1 for a click, 2 for a doubleClick, 3 for a trippleClick,\u0026hellip;\nSending multiple events from a single source #  You can also send multiple events from a single source.\n1  \u0026lt;paper-button @-click=\u0026#34;^^some-event(_privateProperty),^other-event,--checkTapped\u0026#34;\u0026gt; check \u0026lt;/paper-button\u0026gt;   When the button is tapped, some-event and other-event will be fired and the wire \u0026ndash;checkTapped will be triggered.\nStop propagation #  To stop the event propagation to parent elements, add a :STOP to the event wires @-error=\u0026quot;--errorOccured, :STOP\u0026quot;. The wires in this event-chain will be triggered. But the propagation will be stopped.\nPrevent Default #  Prevent default can be achieved by using :PREVENTDEFAULT.\n"});index.add({'id':6,'href':'/docs/fbp-scripting/','title':"Script interaction",'section':"Docs",'content':"Interaction with javascript #  The wires can be hooked and triggered from the script part of your component. This also comes very handy when you are writing tests.\nTrigger a wire imperatively #  To trigger a wire from the javascript part of your component or from a test, call the _FBPTriggerWire method. You can also trigger the wire in the constructor, then the wire will be queued until the flow is parsed and ready.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  class TriggerSample extends FBP(LitElement) { constructor(){ super(); this.data = \u0026#34;Test\u0026#34;; // this wire will be queued  this._FBPTriggerWire(\u0026#34;--wireName\u0026#34;, this.data);  } /** * _FBPReady triggers when the flow is ready */ _FBPReady(){ super._FBPReady(); this._FBPTriggerWire(\u0026#39;--wireName\u0026#39;, this.data);  } /** * To pass data from outside to a wire, use this._FBPTriggerWire() * */ fetchRecord(src){ this._FBPTriggerWire(\u0026#39;--fetchRequested\u0026#39;, src);  } }   Add a wire hook #  To hook on a wire use this._FBPAddWireHook(\u0026quot;--wirename\u0026quot;). This comes very handy at testing, or if you have to manipulate some data, because the component doesnt send it like an other component needs it.\n1 2 3 4 5 6 7 8 9 10  class HookSample extends FBP(LitElement) { constructor() { super(); this._FBPAddWireHook(\u0026#34;--pathChanged\u0026#34;,(d)=\u0026gt;{ // d contains the full content of the event, not only the d.detail  })  } }    The most @-events of the furo base components will fit the ƒ-methods of the corresponding components. It is like playing domino. Read the api guide to learn what which component sends or expects.\n "});index.add({'id':7,'href':'/docs/fbp-bestpractice/','title':"Best Practice",'section':"Docs",'content':"Best Practice #  The best practices are a result from the feedback of our users, thanks to them.\nFeel free to give us your feedback.\nWire and event naming #  In fact you can use any string to name wires, but most of the users are using two dashes in front of the wire name and for the name they use camelCase notation.\nFor the events they use the dashed-case notation, because you can not write @-camelCase.\n1  \u0026lt;furo-button @-click=\u0026#34;--buttonClicked, ^^fired-event\u0026#34;\u0026gt;\u0026lt;/furo-button\u0026gt;   With this notation they can see the difference between a \u0026ndash;wire to an event they fire directly.\nUse declarative wire names, don\u0026rsquo;t be imperative #  When you use declarative names, it would be easier to read and modify a wired program.\nbad example\n1 2 3  \u0026lt;furo-button @-click=\u0026#34;--closeView\u0026#34;\u0026gt;\u0026lt;/furo-button\u0026gt; \u0026lt;my-view ƒ-close=\u0026#34;--closeView\u0026#34;\u0026gt;\u0026lt;/my-view\u0026gt; \u0026lt;data-component ƒ-save=\u0026#34;--closeView\u0026#34;\u0026gt;\u0026lt;/data-component\u0026gt;   good example\n1 2 3  \u0026lt;furo-button @-click=\u0026#34;--closeButtonClicked\u0026#34;\u0026gt;\u0026lt;/furo-button\u0026gt; \u0026lt;my-view ƒ-close=\u0026#34;--closeButtonClicked\u0026#34;\u0026gt;\u0026lt;/my-view\u0026gt; \u0026lt;data-component ƒ-save=\u0026#34;--closeButtonClicked\u0026#34;\u0026gt;\u0026lt;/data-component\u0026gt;   It is a subtile but relevant difference between this two examles.\nUse event delegation #  When you use a set of components, you don\u0026rsquo;t have to wire every single component to the appropriate target. Use event delegation whenever possible. It is faster and easier to read.\nwithout event delegation\n1 2 3 4 5 6 7 8  \u0026lt;div \u0026gt; \u0026lt;mole-hole key=\u0026#34;a\u0026#34; @-closed=\u0026#34;--moleClosed\u0026#34; @-continue=\u0026#34;--continue\u0026#34; @-miss=\u0026#34;--missed\u0026#34; @-whack=\u0026#34;--whacked\u0026#34;\u0026gt;\u0026lt;/mole-hole\u0026gt; \u0026lt;mole-hole key=\u0026#34;s\u0026#34; @-closed=\u0026#34;--moleClosed\u0026#34; @-continue=\u0026#34;--continue\u0026#34; @-miss=\u0026#34;--missed\u0026#34; @-whack=\u0026#34;--whacked\u0026#34;\u0026gt;\u0026lt;/mole-hole\u0026gt; \u0026lt;mole-hole key=\u0026#34;d\u0026#34; @-closed=\u0026#34;--moleClosed\u0026#34; @-continue=\u0026#34;--continue\u0026#34; @-miss=\u0026#34;--missed\u0026#34; @-whack=\u0026#34;--whacked\u0026#34;\u0026gt;\u0026lt;/mole-hole\u0026gt; \u0026lt;mole-hole key=\u0026#34;f\u0026#34; @-closed=\u0026#34;--moleClosed\u0026#34; @-continue=\u0026#34;--continue\u0026#34; @-miss=\u0026#34;--missed\u0026#34; @-whack=\u0026#34;--whacked\u0026#34;\u0026gt;\u0026lt;/mole-hole\u0026gt; \u0026lt;mole-hole key=\u0026#34;g\u0026#34; @-closed=\u0026#34;--moleClosed\u0026#34; @-continue=\u0026#34;--continue\u0026#34; @-miss=\u0026#34;--missed\u0026#34; @-whack=\u0026#34;--whacked\u0026#34;\u0026gt;\u0026lt;/mole-hole\u0026gt; \u0026lt;mole-hole key=\u0026#34;w\u0026#34; @-closed=\u0026#34;--moleClosed\u0026#34; @-continue=\u0026#34;--continue\u0026#34; @-miss=\u0026#34;--missed\u0026#34; @-whack=\u0026#34;--whacked\u0026#34;\u0026gt;\u0026lt;/mole-hole\u0026gt; \u0026lt;/div\u0026gt;    with event delegation\n1 2 3 4 5 6 7 8  \u0026lt;div @-closed=\u0026#34;--moleClosed\u0026#34; @-continue=\u0026#34;--continue\u0026#34; @-miss=\u0026#34;--missed\u0026#34; @-whack=\u0026#34;--whacked\u0026#34;\u0026gt; \u0026lt;mole-hole key=\u0026#34;a\u0026#34;\u0026gt;\u0026lt;/mole-hole\u0026gt; \u0026lt;mole-hole key=\u0026#34;s\u0026#34;\u0026gt;\u0026lt;/mole-hole\u0026gt; \u0026lt;mole-hole key=\u0026#34;d\u0026#34;\u0026gt;\u0026lt;/mole-hole\u0026gt; \u0026lt;mole-hole key=\u0026#34;f\u0026#34;\u0026gt;\u0026lt;/mole-hole\u0026gt; \u0026lt;mole-hole key=\u0026#34;g\u0026#34;\u0026gt;\u0026lt;/mole-hole\u0026gt; \u0026lt;mole-hole key=\u0026#34;w\u0026#34;\u0026gt;\u0026lt;/mole-hole\u0026gt; \u0026lt;/div\u0026gt;    "});index.add({'id':8,'href':'/docs/fbp-debugging/','title':"Debugging",'section':"Docs",'content':"Debugging strategies #  You can use the debugging tools you always used for web development. The eventListeners from furo-fbp are the same eventListeners you have had before.\n img[src*=\"#max\"]{max-width:600px} $0 is the selected element from the elements tab.\n  getEventListeners($0) shows you the attached eventListeners\n Show the fbp listeners on a host #  Use $0.__FBPEventlistener to show all listeners on the host component\n Show the wires on a host #  Use $0.__wirebundle to show all registered wires.\n  Keep in mind that wires without receivers will not show in this list.\n Debugging a single wire #  To debug a single wire write $0._FBPDebug(\u0026quot;--markdown\u0026quot;).\n  Every time this wire triggers, you will see the following information in your console.\n Tracing #  To trace all wires in a host use $0._FBPTraceWires().\n  This will log every triggering wire to the console. In most of the cases, the problems you have solve, are typos in wire names.\n "});index.add({'id':9,'href':'/docs/fbp-lifecycle/','title':"Lifecycle",'section':"Docs",'content':"FBP Lifecycle #  _FBPReady() #  _FBPReady() is called, when the wires are registered and the components are able to receive wire data. This is also the earliest point to enable the tracing.\n1 2 3 4 5 6 7 8 9  class MyComponent extends FBP(LitElement) { // trace all wires  _FBPReady(){ super._FBPReady(); this._FBPTraceWires(); } } window.customElements.define(\u0026#39;my-component\u0026#39;, MyComponent);   The \u0026ndash;FBPready magic wire #  The wire \u0026ndash;FBPready is also triggered when your component is ready.\n"});index.add({'id':10,'href':'/docs/cred-morrison/','title':"Credits",'section':"Docs",'content':"J. Paul Rodker Morrison #  Furo FBP was inspired by the work of Paul Morrison. You will find a lot of interesting material on his page.\n  Flow-Based Programming  J. Paul Rodker Morrison  Some words from the discoverer of Flow Based Programming #   – Just as in the preparation and consumption of food there are the two roles of cook and diner, in FBP application development there are two distinct roles: the component builder and the component user or application designer. The component builder decides the specification of a component, which must also include constraints on the format of incoming data IPs (including option IPs) and the format of output IPs. The specification should not describe the internal logic of the component, although attributes sometimes “leak” from internal to external (restrictions on use are usually of this type). The application designer builds applications using already existing components, or, where satisfactory ones do not exist, s/he will specify a new component, and then see about getting it built. Component designers and users may of course be the same people, but there are two very different types of skill involved. This is somewhat like the designer of a recent popular game, who admitted he was not particularly fast at solving it - his skill was in designing games, not in playing them. The separation between makers and users is so widespread in real life that we don’t pay any attention to it unless it breaks down. In industry, as Wayne Stevens points out, we take for granted the idea that airplane builders do not build their own chairs - they subcontract them to chair manufacturers, who in turn subcontract the cloth to textile manufacturers and so on. In contrast, the world of conventional programming is as if every builder designed his own nails, lumber and dry-wall from scratch. Talk about “reinventing the wheel” - in conventional application development we reinvent the rubber, the nuts and bolts, and even the shape of the wheel! [van Norstand Rheinhold, Flow based Programming (1994). Page 53]  "});})();