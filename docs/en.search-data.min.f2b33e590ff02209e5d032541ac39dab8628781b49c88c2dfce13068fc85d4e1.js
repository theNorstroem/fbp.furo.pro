'use strict';(function(){const indexCfg={cache:true};indexCfg.doc={id:'id',field:['title','content'],store:['title','href','section'],};const index=FlexSearch.create('balance',indexCfg);window.bookSearchIndex=index;index.add({'id':0,'href':'/docs/installation/','title':"Installlation",'section':"Docs",'content':"Installation #  You can use furo FBP directly in your HTML documents or within your own web-components.\nFrom CDN #  FBP and eclipsefuro-web in HTML without installation #  You can use furo-fbp and the furo-web-components without a direct installation by using the precompiled variant of the furo web components.\nThis is the simplest way to get up and running.\n1 2 3 4 5 6  \u0026lt;script\u0026gt; import(\u0026#34;https://cdn.jsdelivr.net/npm/@furo/precompiled@2.0.0-rc.16/dist/DOMFBP.js\u0026#34;).then(() =\u0026gt; { // activate FBP on body  const fbphandle = new DOMFBP(document.body); }); \u0026lt;/script\u0026gt;     Read more about @furo/precompiled here.  open demo  open sandbox  Install the npm module #  To work with lit or native web components you need the npm module @furo/fbp.\n1  npm i -S @furo/fbp   FBP with lit-element #  To use FBP with lit, just extend your class.\n1 2 3 4  class MyComponent extends FBP(LitElement) {  } window.customElements.define(\u0026#39;my-component\u0026#39;, MyComponent);   FBP with native web-components #  To use furo-fbp with native components, call this._appendFBP(this.shadowRoot); to enable fbp.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  class MyComponent extends FBP(HTMLElement) { constructor() { super(); // Create a shadow root to the element.  this.attachShadow({mode: \u0026#39;open\u0026#39;}); this.shadowRoot.appendChild(template.content.cloneNode(true)); // Append FBP to my-component  this._appendFBP(this.shadowRoot);  } } window.customElements.define(\u0026#39;my-component\u0026#39;, MyComponent);   FBP with polymer #  To use FBP with polymer, just extend your class.\n1 2 3 4  class MyComponent extends FBP(PolymerElement) {  } window.customElements.define(\u0026#39;my-component\u0026#39;, MyComponent);   "});index.add({'id':1,'href':'/docs/precompiled/','title':"Precompiled",'section':"Docs",'content':"@furo/precompiled #  The @furo/precompiled package is for those who want to use the furo componetnt directly in HTML. There is no build step needed. It is a convenient way to use the components to prototype some ideas or just play around with FBP without a complex installation procedure. When you know that your ideas work, transfer them 1:1 to a web component, so others can install, use and extend them.\nLook at the sample folder in the repo to see an example of what is possible.\n Note This package was created to teach furo FBP and for creating our demos, so we can use and show our components in a HUGO generated page. Some of the files are very big at the moment, because they are not optimized for file size yet.\n This documentation uses @furo/precompiled at any place where you can see a [demo/source/flow] panel. All that was needed was to load the precompiled scripts via CDN.\n  open demo  open sandbox  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;/\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;/\u0026gt; \u0026lt;meta http-equiv=\u0026#34;X-UA-Compatible\u0026#34; content=\u0026#34;ie=edge\u0026#34;/\u0026gt; \u0026lt;!-- This module contains the light bulb --\u0026gt; \u0026lt;script type=\u0026#34;module\u0026#34; src=\u0026#34;https://cdn.jsdelivr.net/npm/@furo/precompiled@2.0.0-rc.16/dist/doc-helper.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; import( \u0026#34;https://cdn.jsdelivr.net/npm/@furo/precompiled@2.0.0-rc.16/dist/DOMFBP.js\u0026#34; ).then(() =\u0026gt; { // activate FBP on body  const fbphandle = new DOMFBP(document.body); // enable tracing  fbphandle._FBPTraceWires(); }); \u0026lt;/script\u0026gt; \u0026lt;title\u0026gt;Static Template\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;This is a static template, there is no bundler or bundling involved!\u0026lt;/h1\u0026gt; \u0026lt;light-bulb fn-toggle=\u0026#34;--lightSwitchClicked\u0026#34;\u0026gt;\u0026lt;/light-bulb\u0026gt; \u0026lt;button at-click=\u0026#34;--lightSwitchClicked\u0026#34;\u0026gt;i am a lightswitch\u0026lt;/button\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt;   Compatibility Table #  This compatibility list is only meant for the precompiled components.\n "});index.add({'id':2,'href':'/docs/fbp-basics/','title':"Getting Started",'section':"Docs",'content':"Getting Started #  Write your applications like you make the concept for your application. Normaly you draw a few components and some arrows to connect the components, to describe your intention. Why you don’t do the same to write your app or component? Use existing web-components and wire them to build up your application.\nFuro FBP 101 #  In furo-FBP you connect events from one component to methods of anohter component. If you get this simple concept, you have understand already 90% of the things you need to write a program.\nConnecting things #  We have a lightswitch furo-button and a light bulb light-bulb which we want to toggle when the switch is clicked.\nWhen the button fires a click event, the action will trigger the toggle method of the light-bulb because it is connected by the wire --lightSwitchClicked.\n  i am a lightswitch   This doesnt look very impressive in the first moment. But as you can see, there is no scripting involved and there are no id\u0026rsquo;s assigned to the components.\nHint\n Click on demo to see the flow in action. Click on source to see the corresponding source. Click on flow to see the resulting flow of the source.   Multiple targets #  A wire can have as many targets as you want.\nSo the wire --lightSwitchClicked can trigger multiple targets if you want.\n    i am a lightswitch    When you press the button, all elements which are connected to the wire will trigger the defined function. In this example the last light-bulb is not connected.\nName of the wire\nYou can name a wire with alphanumeric characters without a \u0026ldquo;space\u0026rdquo;.\nIt is a good practice to name the wire by the thing that happened like --saveClicked or by the values it will transport like --responseData. The dashes are not needed, but it makes the code easier to read too.\n Name of the wire\nSometimes people tend to name the wire by the target action that the wire will trigger (--saveData). THIS IS NOT a good idea and will result in unreadable flows.\nAssume that your team want to introduce some other features, like playing a animation.\n1 2 3 4 5  \u0026lt;!-- bad wire name--\u0026gt; \u0026lt;some-animation fn-play=\u0026#34;--saveData\u0026#34;\u0026gt;\u0026lt;/some-animation\u0026gt; \u0026lt;!-- good wire name --\u0026gt; \u0026lt;some-animation fn-play=\u0026#34;--saveClicked\u0026#34;\u0026gt;\u0026lt;/some-animation\u0026gt;     Multiple sources #  A wire is not limited as a point to point connection and can have multiple sources.\n  lightswitch 1 lightswitch 2   It doesn\u0026rsquo;t matter if you press the first or the second light switch. Both of them will trigger the wire--lightSwitchClicked, which will invoke the toggle method on the light-bulb.\nMultiple sources and targets #  A wire is not limited as a point to point connection and can have multiple sources and also have multiple targets.\n     lightswitch lightswitch 2   If you look at the source of this example, it doesn\u0026rsquo;t look very complex, the resulting flow of this example is quite complex.\nTriggering multiple wires from one source event #  Sometimes you want to trigger multiple wires from one source event. You can do this by separating them with a comma. at-click=\u0026quot;--lightSwitchClicked, --blinkerClicked\u0026quot;\n    lightswitch  Stop the blinking   When you press the button, it will trigger the --lightSwitchClicked and the --blinkerClicked wire.\nReceiving multiple wires on a target #  You can receive from multiple wires by comma separating them.\n   i am a lightswitch blinkswitch  Stop the blinking   *The light bulb on the top right will be triggered by the --lightSwitchClicked and --intervallPulse wire *\n"});index.add({'id':3,'href':'/docs/fbp-cheatsheet/','title':"Cheat Sheet",'section':"Docs",'content':"Cheat Sheet #  Furo fbp only knows a few of keywords to control the application flow.\n  at-  fn-  set-  at-fnret-  ^  ^^  -^  (( ))  Adding event listeners #  The at- keyword let you bind a wire to an event. This can be any browser event or custom event.\nat-click=\u0026quot;--lightSwitchClicked\u0026quot; Assign a wire which should be triggered when the event happens. By default the event.detail property is put as data on the wire.\nTo put the event root on the wire, use at-click=\u0026quot;--lightSwitchClicked(*)\u0026quot;.\nExecute exposed methods #  The fn- keyword let you trigger methods with the data which was put on the wire as argument.\nIf a method needs multiple arguments you have to put a array on the wire data, otherwise only the first argument is filled.\n  i am a lightswitch    The classic notation for at- is @-. The classic notation for fn- is ƒ-.\n Set member variables of a component #  The set- keyword let you set member variables (not the attributes) of element.\n\u0026lt;span set-inner-text=\u0026quot;--labelReceived\u0026quot;\u0026gt; initial label \u0026lt;/span\u0026gt; Will set the attribute innerText on the span, as soon the wire --labelReceived is triggered.\n The classic notation for set- is ƒ-..\n Setting member variables of the host component #  The (( )) keyword let you store data from events on member variables of the host component.\n\u0026lt;my-component at-event-name=\u0026quot;((color))\u0026quot;\u0026gt; This will store the data of the event event-name on the host member variable color.\nEmitting events #  Non bubbling events #  Non bubbling events will, as the name says, not bubble and stop at the next dom parent. To fire a non-bubbling-event use ^event-name.\nBubbling events #  To fire a bubbling-event use ^^event-name. Bubbling is useful if you want or have to use the event in a parent component.\nNon bubbling host events #  With -^ you can dispatch an event, which is available on the host only, but does not bubble.\n  i am a lightswitch setcolor   Receiving the return values from fn- calls #  The at-fnret- keyword let you wire the response of a method call. The data which is put on the wire is the response of the method.\nStop propagation #  The keyword :STOP is used to stop the event propagation to parent elements.\nPrevent default #  The keyword :PREVENTDEFAULT will set the prevent default on the event.\n"});index.add({'id':4,'href':'/docs/fbp-wires-data/','title':"Wire Data",'section':"Docs",'content':"Data on wires #  Wires are not limited to triggering something, they also transport information.\nNote\nBy default the content of EVENT.detail is passed to the target. If an event does not have a detail property, the receiver will get a undefined.\n Passing useful data to target #       The color picker dispatches a value-changed event, with the color as payload.\nSend the complete event instead of event.detail #  You can put the complete event or any sub.property of the event on the wire by defining the details at the producer / triggerer.\nProducer (at-) #  You can define exactly what you want to put on the wire on the producing side.\n at-event=\u0026quot;\u0026ndash;wireName(*)\u0026quot; will send the complete event. at-event=\u0026quot;\u0026ndash;wireName(*.key)\u0026quot; will send the property key of the event.  Receiver (fn-) #  You can pass a subset of the data on a wire to a receiver.\n fn-doit=\u0026quot;\u0026ndash;wireName(*.title)\u0026quot; will call doit(wiredata.title)on the receiver. fn-doit=\u0026quot;\u0026ndash;wireName(*.page.2.title)\u0026quot; will call doit(wiredata.page[2].title) on the receiver with checks that index 2 and the sub property really exist.  Storing event data on a class member property (aka parking) #  Sometimes you want to store data for later usage. To store data from an event write the property that you want to update in a double bracket ((targetProperty)).\n at-value-changed=\u0026quot;((color1)) will update the component property color1 with the value of EVENT.detail.  Note\nKeep in mind that you will overwrite existing properties of your host. A name like shadowRoot can cause problems.\n     Look at the example below to see how you can use parked data\nSending host member properties with events #  To send parked data, write the property name in brackets after the wire.\n at-click=\u0026quot;\u0026ndash;newColor(color1)\u0026quot; will put the value of color1 on the wire --newColor instead of the detail value of the click event.    setColor    "});index.add({'id':5,'href':'/docs/fbp-wires-more/','title':"Compatibility",'section':"Docs",'content':"Working with suboptimal components #  Some components that you may want or have to use are not dispatching events or receiving data by methods. Therefore, furo FBP has some features to work with them too.\nSetting a member value #  To set a value of a component you use can be done with the set-property.\n A click counter   Note, a property is not an attribute.\nYou have to know what you do. This is a direct manipulation of a component and maybe there is some reason why it does not expose the property.\n Wireing responses from method calls #  When the method that you have wired only returns data that you want to use, you can wire the response with at-fnret-methodname.\n calculate sqrt      The response of the calculate(n) method is avaliable on the wire --calculatedSqrRoot.\nSpread arguments #  When a receiver mehtod accepts multiple arguments or is a spread operator and the data on the wire is spreadable, furo FBP will handle this for you correctly.\n"});index.add({'id':6,'href':'/docs/fbp-events/','title':"Custom Events",'section':"Docs",'content':"Fireing custom events #  Web Components use events to communicate state changes up the DOM tree to parent elements.\nFuro also provides a notation for events which allows you to specify events in a declarative manner. This is very useful when you want to trigger a event with a more specific name then the originating event has.\n*On the first view, it does not make sense to rename events. Take a look at the example below to get a better understanding. controller-component\n play pause stop   my-player\n     Imagine a simple controller component with some buttons. Each of them will dispatch a simple click. Using at-click on the controller inside of the my-player can not distinguish which button was pressed.\n learn more about events\u0026hellip;\nNon bubbling events #  Non bubbling events will, as the name says, not bubble and stop at the next dom parent.\nTo fire a non-bubbling-event use ^event-name.\n Search    Bubbling events #  To fire a bubbling-event use ^^event-name. Bubbling is useful if you want or have to use the event in a parent component. It is a good practice to document the bubbling events from the child components.\n Search    the general-error event will bubble.\nNon bubbling host events #  With -^ you can dispatch an event, which is available on the host only, but does not bubble. This is useful when you want to mimic the blur event (which does not bubble) on the outside of your component.\nSending host data with events #  Sometimes you want to send some values with your event, when the default event.detail is not useful. You can send any host property with your event by giving the property name in brackets like ^^some-event(propertyName) .\nbubbling event with custom data\n1  \u0026lt;paper-button at-click=\u0026#34;^^some-event(_privateProperty)\u0026#34;\u0026gt; check \u0026lt;/paper-button\u0026gt;   The click event sends usually a number for the amount of clicks with a certain time distance. So it will send 1 for a click, 2 for a doubleClick, 3 for a trippleClick,\u0026hellip;\nSending multiple events from a single source #  You can also send multiple events from a single source.\n1  \u0026lt;paper-button at-click=\u0026#34;^^some-event(_privateProperty),^other-event,--checkTapped\u0026#34;\u0026gt; check \u0026lt;/paper-button\u0026gt;   When the button is tapped, some-event and other-event will be fired and the wire \u0026ndash;checkTapped will be triggered.\nStop propagation #  To stop the event propagation to parent elements, add a :STOP to the event wires at-error=\u0026quot;--errorOccured, :STOP\u0026quot;. The wires in this event-chain will be triggered. But the propagation will be stopped.\nPrevent Default #  Prevent default can be achieved by using :PREVENTDEFAULT.\n"});index.add({'id':7,'href':'/docs/fbp-scripting/','title':"Script interaction",'section':"Docs",'content':"Interaction with javascript #  The wires can be hooked and triggered from the script part of your component. This also comes very handy when you are writing tests.\nTrigger a wire imperatively #  To trigger a wire from the javascript part of your component, call the _FBPTriggerWire method.\nYou can also trigger the wire in the constructor, in this case the wire will be queued until the flow is parsed and ready.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  class TriggerSample extends FBP(LitElement) { constructor(){ super(); this.data = \u0026#34;Test\u0026#34;; // this wire will be queued  this._FBPTriggerWire(\u0026#34;|--wireName\u0026#34;, this.data);  } /** * _FBPReady triggers when the flow is ready */ _FBPReady(){ super._FBPReady(); this._FBPTriggerWire(\u0026#34;|--wireName\u0026#34;, this.data);  } /** * To pass data from outside to a wire, use this._FBPTriggerWire() * */ fetchRecord(src){ this._FBPTriggerWire(\u0026#34;|--fetchRequested\u0026#34;, src);  } }   Add a wire hook #  To hook on a wire use this._FBPAddWireHook(\u0026quot;--wirename\u0026quot;). This comes very handy at testing, or if you have to manipulate some data, because the component doesnt send it like an other component needs it.\n1 2 3 4 5 6 7 8 9 10  class HookSample extends FBP(LitElement) { constructor() { super(); this._FBPAddWireHook(\u0026#34;--pathChanged\u0026#34;,(e)=\u0026gt;{ // On hooks `e` contains the complete event, not only the `e.detail`  })  } }    The most at-events of the furo base components will fit the fn-methods of the corresponding components. It is like playing domino.\n "});index.add({'id':8,'href':'/docs/fbp-scope/','title':"Scope",'section':"Docs",'content':"Scope #  The scope of a FBP program is COMPONENT SCOPE. All wires inside a component can be used.\nParked data is set on the component.\nEverything inside of a Template tag is not accessible through the wires.\n"});index.add({'id':9,'href':'/docs/fbp-bestpractice/','title':"Best Practice",'section':"Docs",'content':"Best Practice #  The best practices are a result from the feedback of our users, thanks to them.\nFeel free to give us your feedback.\nWire and event naming #  In fact you can use any string to name wires, but most of the users are using two dashes in front of the wire name and for the name they use camelCase notation.\nFor the events they use the dashed-case notation, because you can not write at-camelCase.\n1  \u0026lt;furo-button at-click=\u0026#34;--buttonClicked, ^^fired-event\u0026#34;\u0026gt;\u0026lt;/furo-button\u0026gt;   With this notation they can see the difference between a \u0026ndash;wire to an event they fire directly.\nUse declarative wire names, don\u0026rsquo;t be imperative #  When you use declarative names, it would be easier to read and modify a wired program.\nbad example\n1 2 3  \u0026lt;furo-button at-click=\u0026#34;--closeView\u0026#34;\u0026gt;\u0026lt;/furo-button\u0026gt; \u0026lt;my-view fn-close=\u0026#34;--closeView\u0026#34;\u0026gt;\u0026lt;/my-view\u0026gt; \u0026lt;data-component fn-save=\u0026#34;--closeView\u0026#34;\u0026gt;\u0026lt;/data-component\u0026gt;   good example\n1 2 3  \u0026lt;furo-button at-click=\u0026#34;--closeButtonClicked\u0026#34;\u0026gt;\u0026lt;/furo-button\u0026gt; \u0026lt;my-view fn-close=\u0026#34;--closeButtonClicked\u0026#34;\u0026gt;\u0026lt;/my-view\u0026gt; \u0026lt;data-component fn-save=\u0026#34;--closeButtonClicked\u0026#34;\u0026gt;\u0026lt;/data-component\u0026gt;   It is a subtile but relevant difference between this two examles.\nUse event delegation #  When you use a set of components, you don\u0026rsquo;t have to wire every single component to the appropriate target. Use event delegation whenever possible. It is faster and easier to read.\nwithout event delegation\n1 2 3 4 5 6 7 8  \u0026lt;div \u0026gt; \u0026lt;mole-hole key=\u0026#34;a\u0026#34; at-closed=\u0026#34;--moleClosed\u0026#34; at-continue=\u0026#34;--continue\u0026#34; at-miss=\u0026#34;--missed\u0026#34; at-whack=\u0026#34;--whacked\u0026#34;\u0026gt;\u0026lt;/mole-hole\u0026gt; \u0026lt;mole-hole key=\u0026#34;s\u0026#34; at-closed=\u0026#34;--moleClosed\u0026#34; at-continue=\u0026#34;--continue\u0026#34; at-miss=\u0026#34;--missed\u0026#34; at-whack=\u0026#34;--whacked\u0026#34;\u0026gt;\u0026lt;/mole-hole\u0026gt; \u0026lt;mole-hole key=\u0026#34;d\u0026#34; at-closed=\u0026#34;--moleClosed\u0026#34; at-continue=\u0026#34;--continue\u0026#34; at-miss=\u0026#34;--missed\u0026#34; at-whack=\u0026#34;--whacked\u0026#34;\u0026gt;\u0026lt;/mole-hole\u0026gt; \u0026lt;mole-hole key=\u0026#34;f\u0026#34; at-closed=\u0026#34;--moleClosed\u0026#34; at-continue=\u0026#34;--continue\u0026#34; at-miss=\u0026#34;--missed\u0026#34; at-whack=\u0026#34;--whacked\u0026#34;\u0026gt;\u0026lt;/mole-hole\u0026gt; \u0026lt;mole-hole key=\u0026#34;g\u0026#34; at-closed=\u0026#34;--moleClosed\u0026#34; at-continue=\u0026#34;--continue\u0026#34; at-miss=\u0026#34;--missed\u0026#34; at-whack=\u0026#34;--whacked\u0026#34;\u0026gt;\u0026lt;/mole-hole\u0026gt; \u0026lt;mole-hole key=\u0026#34;w\u0026#34; at-closed=\u0026#34;--moleClosed\u0026#34; at-continue=\u0026#34;--continue\u0026#34; at-miss=\u0026#34;--missed\u0026#34; at-whack=\u0026#34;--whacked\u0026#34;\u0026gt;\u0026lt;/mole-hole\u0026gt; \u0026lt;/div\u0026gt;    with event delegation\n1 2 3 4 5 6 7 8  \u0026lt;div at-closed=\u0026#34;--moleClosed\u0026#34; at-continue=\u0026#34;--continue\u0026#34; at-miss=\u0026#34;--missed\u0026#34; at-whack=\u0026#34;--whacked\u0026#34;\u0026gt; \u0026lt;mole-hole key=\u0026#34;a\u0026#34;\u0026gt;\u0026lt;/mole-hole\u0026gt; \u0026lt;mole-hole key=\u0026#34;s\u0026#34;\u0026gt;\u0026lt;/mole-hole\u0026gt; \u0026lt;mole-hole key=\u0026#34;d\u0026#34;\u0026gt;\u0026lt;/mole-hole\u0026gt; \u0026lt;mole-hole key=\u0026#34;f\u0026#34;\u0026gt;\u0026lt;/mole-hole\u0026gt; \u0026lt;mole-hole key=\u0026#34;g\u0026#34;\u0026gt;\u0026lt;/mole-hole\u0026gt; \u0026lt;mole-hole key=\u0026#34;w\u0026#34;\u0026gt;\u0026lt;/mole-hole\u0026gt; \u0026lt;/div\u0026gt;    "});index.add({'id':10,'href':'/docs/fbp-debugging/','title':"Debugging",'section':"Docs",'content':"Debugging strategies #  You can use the debugging tools you always used for web development. The eventListeners from furo-fbp are the same eventListeners you have had before.\n img[src*=\"#max\"]{max-width:600px} $0 is the selected element from the elements tab.\n  getEventListeners($0) shows you the attached eventListeners\n Show the fbp listeners on a host #  Use $0.__FBPEventlistener to show all listeners on the host component\n Show the wires on a host #  Use $0.__wirebundle to show all registered wires.\n  Keep in mind that wires without receivers will not show in this list.\n Debugging a single wire #  To debug a single wire write $0._FBPDebug(\u0026quot;--markdown\u0026quot;).\n  Every time this wire triggers, you will see the following information in your console.\n Tracing #  To trace all wires in a host use $0._FBPTraceWires().\n  This will log every triggering wire to the console. In most of the cases, the problems you have to solve, are caused by typos in wire names.\n "});index.add({'id':11,'href':'/docs/fbp-lifecycle/','title':"Lifecycle",'section':"Docs",'content':"FBP Lifecycle #  _FBPReady() #  _FBPReady() is called, when the wires are registered and the components are able to receive wire data.\n1 2 3 4 5 6 7 8 9 10 11  class MyComponent extends FBP(LitElement) { /** * flow is ready lifecycle method */ _FBPReady() { super._FBPReady() this._FBPTraceWires() } } window.customElements.define(\u0026#39;my-component\u0026#39;, MyComponent);   The |\u0026ndash;FBPready magic wire #  The wire |--FBPready is triggered when your component is ready.\nThis can be used as a start trigger for your component.\n"});index.add({'id':12,'href':'/docs/visual-analysis/','title':"Visual analysis",'section':"Docs",'content':"Visual Application Analysis #  Inspect your application logic visually by using viz.\nStarting a viz.furo.pro session #  Start from body #  To start a viz session just type viz() in your browser console. This will open and connect your current browser tab to viz.furo.pro where you can see your application flow. By a double click on a component, viz will request the component from your application and render it.\nStart from a particular component #  Instead of clicking down until you have reached the component you are interested in, you can start viz with a reference to your component.\n example with chrome*   Use the picker to select an element in the page it will be highlighted in the element view and a reference is available with $0 start viz with a reference to the element by typing viz($0)  Examples #   viz started from root\n component: app-shell\n A wire which has no connection to target will be displayed as a red circle\nHow to read the flow graph #  If you are familiar with fbp, you should not have any problem to read the graph.\n  The boxes represent the used components. The name of the component is on the top left (furo-app-flow)\n Boxes with dashed lines have a comment in the source. Hover on the box to read the comment    The blue lines are the wires.\n Hover on them to read the wire name, like --unauthorized.    The small blue boxes with an at- are the catched events.\n Hover on them to read the used name and more.    The small green boxes with an fn- are the triggerer for the methods of the component.\n  The small black boxes are attributes without a value assignment.\n These are often boolean flags like hidden or readonly which are setted.    The small orange boxes are string attributes of the component which are setted.\n Hover on them to read the setted string.    The orange dots are indicating a wire from nowhere or a wire which was triggered from the source (like this._FBPTriggerWire(\u0026quot;\u0026ndash;dataReceived\u0026quot;,data)) or from outside (like \u0026ndash;pageEntered from furo-pages).\n If you trigger a wire from the source and use the prefix |-- on the wire, the dot will turn green    The red dots are indicating a wire which goes nowhere or a wire which is cathced in the source (like this._FBPAddWireHook(\u0026quot;\u0026ndash;wireName\u0026quot;,(e)=\u0026gt;{ \u0026hellip; });\n  Keyboard shortcuts #   f on the buttons toggles the fullscreen mode. Press \u0026ldquo;esc\u0026rdquo; to get back. ctrl v or cmd v renders the clipboard content. Do not forget to allow your browser to accept the clipboard content. arrow-left, arrow-right ◀, ▶ re renders the last pasted content. Backspace removes the current view.  Mouse controls #   scroll down zooms the flow in. scroll up zooms out. moving the mouse with mousedown pans the flow.  Touch controls #   pinch in zooms the flow in. pinch out zooms the flow out. paning (with 2 fingers) pans the flow.  "});index.add({'id':13,'href':'/docs/cred-morrison/','title':"Credits",'section':"Docs",'content':"J. Paul Rodker Morrison #  Furo FBP was inspired by the work of Paul Morrison. You will find a lot of interesting material on his page.\n  Flow-Based Programming  J. Paul Rodker Morrison  Some words from the discoverer of Flow Based Programming #   – Just as in the preparation and consumption of food there are the two roles of cook and diner, in FBP application development there are two distinct roles: the component builder and the component user or application designer. The component builder decides the specification of a component, which must also include constraints on the format of incoming data IPs (including option IPs) and the format of output IPs. The specification should not describe the internal logic of the component, although attributes sometimes “leak” from internal to external (restrictions on use are usually of this type). The application designer builds applications using already existing components, or, where satisfactory ones do not exist, s/he will specify a new component, and then see about getting it built. Component designers and users may of course be the same people, but there are two very different types of skill involved. This is somewhat like the designer of a recent popular game, who admitted he was not particularly fast at solving it - his skill was in designing games, not in playing them. The separation between makers and users is so widespread in real life that we don’t pay any attention to it unless it breaks down. In industry, as Wayne Stevens points out, we take for granted the idea that airplane builders do not build their own chairs - they subcontract them to chair manufacturers, who in turn subcontract the cloth to textile manufacturers and so on. In contrast, the world of conventional programming is as if every builder designed his own nails, lumber and dry-wall from scratch. Talk about “reinventing the wheel” - in conventional application development we reinvent the rubber, the nuts and bolts, and even the shape of the wheel! [van Norstand Rheinhold, Flow based Programming (1994). Page 53]  "});})();